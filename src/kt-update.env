#!/bin/bash
#
# Copyright (C) 2018-2019 Super Sonic Imagine <software@supersonicimagine.com>
#

KT_VERSION="0.18.9"

## Set locales to default (english) because we sometime rely on them (apt).
export LANG="C"
export LC_ALL="C"

## general default options ##
IDENTIFIER="${IDENTIFIER:-stable}"
WGET_OPTIONS="${WGET_OPTIONS:-"--no-verbose"}"
export DEBIAN_FRONTEND="noninteractive"
KT_GETCONF_PERIOD="7"

# apt default options. Please use only '-o' form of configuration options.
APT_OPTIONS="-o quiet=1 -o APT::Get::Assume-Yes=true -o APT::Get::allow-downgrades=true -o APT::Get::Purge=true"
APT_OPTIONS+=' -o Dpkg::Options::=--force-confnew -o Dpkg::Options::=--force-confmiss'
APT_OPTIONS+=' -o Dpkg::Use-Pty=0'

kt_conf() {
	local helpmsg=" conf       manage configurable values. Options (exclusive):
    -p, --print [EXTRAKEYS...]       Print value of all known keys and EXTRAKEYS.
    -r, --read  FILE [EXTRAKEYS...]  Read and set value of known keys and EXTRAKEYS from FILE.
    -w, --write FILE [KEYS...]       Write main current conf keys or KEYS to FILE.
    -i, --interactive FILE [KEYS...] Ask for main conf keys or KEYS, set and write them to FILE."

	local file key kt_wconf_keys="KT_SERVER_URI IDENTIFIER"
	local kt_conf_keys="$kt_wconf_keys WGET_OPTIONS APT_OPTIONS DEBIAN_FRONTEND KT_GETCONF_PERIOD"
	local interactive=false

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			-p|--p*)
				shift
				for key in $kt_conf_keys ; do eval echo "$key=\\'\$$key\\'" ; done
				for key in "$@" ; do eval echo "$key=\\'\$$key\\'" ; done
				return ;;
			-r|--r*)
				shift
				file="$1"
				shift
				. <(grep "^[[:space:]]*\(${kt_conf_keys// /\\|}\)[[:space:]]*[+=]" "$file" ) || return 2
				local tmp="$@"
				if [ "$tmp" ] ; then
					. <(grep "^[[:space:]]*\(${tmp// /\\|}\)[[:space:]]*[+=]" "$file" ) || return 2
				fi
				return ;;
			-i|--i*)
				interactive=true ;&
			-w|--w*)
				shift
				file="$1"
				shift
				for key in ${@:-$kt_wconf_keys} ; do
					$interactive && eval read -p \"$key [\$$key] ? \"
					$interactive && [ "$REPLY" ] && read $key <<< "$REPLY"
					grep -q -s "^$key=" "$file" && eval sed -i " s,^$key=.*,$key=\\'\$$key\\',g " "$file" || eval echo "$key=\\'\$$key\\'" >> "$file" || return 2
				done ;
				return ;;
			*) break ;;
		esac
	done
	echo -e "Error: Unrecognized option/parameters $1\n$helpmsg" >&2 ; return 2
}

if [ "$BASH_SOURCE" != "$(readlink -f -- "$0")-update.env" ] ; then
	echo -e "\n$BASH_SOURCE $KT_VERSION\n"
	kt_conf --print
	echo "LIBDIR=$LIBDIR"
	echo "TMPDIR=$TMPDIR"
fi

kt_cleancache() {
	# Clean cache #TODO: maybe better select files to clean instead of a simple '*_*'.
	rm -f /var/lib/apt/lists/*_* 
	touch "$LIBDIR/cache-cleaned"
}

# Output required packages
# Return: like grep: 0 if there are required packages, 1 if not, and 2 or greater if an error occurred.
kt_requiredpkgs() {
	local helpmsg="$FUNCNAME output packages required by the \"kt:check:package:\" directive in kt-remote.list"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			*) echo -e "Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done
	#TODO: manage flags, and then implement parameters/options to filter depending on them

	local list ret=1
	list="$(grep "^#~kt:check:package:" /etc/apt/sources.list.d/kt-remote.list)" || return $?
	while IFS=":" read dc dc dc flags wheretoget package ; do
		# flag 'o': optional package
		[ -z "$package" ] && echo "Warning: Incomplete directive kt:check:package:$flags:$wheretoget:..." >&2 && continue
		echo "$package"
		ret=0
	done <<< "$list"
	return $ret
}

# 1 - Display on stderr packages not correctly installed
# 2 - then run apt-get check
# 3 - then check presence of required package
# Return the number of packages with a status error.
#   + apt-get check
#   + the number of missing required packages
kt_check() {
	local helpmsg=" check        check configuration and packages status"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			*) echo -e "Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done

	local ret=$(dpkg -l | grep "^[a-zA-Z]*[A-Z]\>" | tee >( wc -l ) >&2 )

	apt-get $APT_OPTIONS check || ((ret++))

	local iversion cversion dc flags wheretoget package
	for package in $(kt_requiredpkgs) ; do
		if ! dpkg-query --showformat='Check ${Package}... ' --show "$package" ; then
			((++ret))
			continue
		fi
		iversion=$(apt-cache policy "$package" | sed -n ' s, *Installed: ,,p ')
		cversion=$(apt-cache policy "$package" | sed -n ' s, *Candidate: ,,p ')
		if [ "$iversion" != "$cversion" ] ; then
			echo "Error: installed version ($iversion) differs from candidate version ($cversion)" >&2
			((++ret))
		else
			echo "OK"
		fi
	done
	((ret)) && return $((ret>254 ? 254 : ret))
	return 0
}

kt_checknfix() {
    local helpmsg=" checknfix    check conf and packages status, and try repair if NOK"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			*) echo -e "Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done

	local i err cmd
	if ! kt_check ; then
		xsplashaa-client -h > /dev/null && cmd=xsplashaa-client || cmd=true
		$cmd --error='Fixing brocken distribution...' --socket='/var/xsplashaa/tmp/xsplashaa-socket'
		if ! kt_upgrade ; then
			# sleep because xsplashaa overwrite previous messages => need little time to read them.
			sleep 1
			$cmd --error='Using network connection...' --socket='/var/xsplashaa/tmp/xsplashaa-socket'
			echo "$FUNCNAME: Using network connection..." >&2
			sleep 3
			# try at most 6 kt_getconf (network has to be up)
			for ((i=0;i<6;i++)) ; do
				err="$(kt_getconf 2>&1)" && break
				$cmd --error="$err" --socket='/var/xsplashaa/tmp/xsplashaa-socket'
				sleep 5;
			done
			kt_cleancache
			kt_update
			$cmd --error='Repairs in progress...' --socket='/var/xsplashaa/tmp/xsplashaa-socket'
			if ! kt_upgrade ; then
				$cmd --fatal-error='Distribution auto-repair FAIL' --socket='/var/xsplashaa/tmp/xsplashaa-socket'
				return 1
			fi
		fi
		for package in $(kt_requiredpkgs) ; do
			if ! apt-get $APT_OPTIONS install "$package" ; then
				$cmd --fatal-error='Distribution auto-repair FAIL (to install '"$package"')' --socket='/var/xsplashaa/tmp/xsplashaa-socket'
				return 1
			fi
		done
		$cmd --message='Distribution auto-repair SUCCESS' --socket='/var/xsplashaa/tmp/xsplashaa-socket'
	fi
	return 0
}

kt_simulate() {
    local helpmsg=" simulate     simulate installation"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			*) echo -e "Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done

	apt-get $APT_OPTIONS --no-act dist-upgrade
}

kt_download() {
    local helpmsg=" download     download new packages to install"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			*) echo -e "Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done

	apt-get $APT_OPTIONS autoclean || return $?

	#APT_OPTIONS+=" -o Acquire::http::Dl-Limit=2000"
	apt-get $APT_OPTIONS -o APT::Get::Download-Only=true dist-upgrade || return $?
}

# send GPGKEY (public certificate) to SERVER and get a (secret) uri used to get sources.list.
# Then sources.list is checked to replace previous sources.list.
# If success files getconf_date and getconf_id are update in \$LIBDIR.
# Usage: $FUNCNAME [OPTION...] [IDENTIFIER]"
kt_getconf() {
    local helpmsg=" getconf         get distro configuration (a customized sources.list which may contain some kt's extensions)"

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			--) shift ; break ;;
			-*) echo -e "Error: Unrecognized option $1\n$helpmsg" >&2 ; return 2 ;;
			*) break ;;
		esac
		shift
	done

	touch "$LIBDIR/getconf_date" # (create file if not exist, and store kt_getconf attempt in it's status metadata)

	local suri ret id="${1:-$IDENTIFIER}"

	if [ -z "$id" ] ; then
		echo > "$LIBDIR/getconf_id"
		echo "$FUNCNAME immediately ends due to empty IDENTIFIER." >&2
		return 196
	fi

	# Send GPGKEY (public certificate) if IDENTIFIER has changed.
	# If server Accept the GPGKEY, it return the secret URI (sould be https) or directly sources.list, encrypted with the given GPGKEY.

	if (( ${#KT_SERVER_URI} < 11 )) ; then
		echo "$FUNCNAME: No server correctly configured" >&2
		return 197
	fi

	# For the moment, secret URI = $KT_SERVER_URI/cids/$IDENTIFIER/
	suri="$KT_SERVER_URI/cids/$id/"

	# Update sources.lists according to previous RESPONSE

	wget $WGET_OPTIONS -O "$LIBDIR/remote_sources.list" "${suri}sources.list" || return $?

	if cmp -s /etc/apt/sources.list.d/kt-remote.list "$LIBDIR/remote_sources.list" > /dev/null ; then
		echo "Remote apt sources list: unchanged"
		echo "$KT_SERVER_URI" > "$LIBDIR/getconf_server" || return $?
		echo "$id" > "$LIBDIR/getconf_id" || return $?
		date "+%s" > "$LIBDIR/getconf_date" || return $?
		return 0
	fi

	echo "New remote apt sources list:"

	if ! grep "^deb " "$LIBDIR/remote_sources.list" ; then
		echo "$FUNCNAME: Remote apt sources list: INVALID" >&2
		return 198
	fi

	mkdir -p "$TMPDIR/lists/partial"
	apt-get -o Dir::Etc::sourcelist="$LIBDIR/remote_sources.list" -o Dir::Etc::sourceparts="" -o Dir::State::lists="$TMPDIR/lists" update 2>&1 >/dev/null | grep -v "is performed unsandboxed" | cat > "$TMPDIR/result" || return $?
	ret=${PIPESTATUS[0]}
	if ((ret)) || [ -s "$TMPDIR/result" ] ; then # ERROR or Warnings occurs
		cat "$TMPDIR/result"
		echo "$FUNCNAME: Checking remote apt sources list: FAIL ($ret)" >&2
		return 199
	fi
	#TODO check if critical kt::extrafile or critical kt::(pre|post)scripts inside sources.list are downloadable.

	# Success -> disable apt/sources.list (comment all)
	if ! grep "apt/sources.list should NOT be used anymore" /etc/apt/sources.list ; then
		sed -i "s,^,#, ; 1i ## $(date -I): managed by kt-update, /etc/apt/sources.list should NOT be used anymore" /etc/apt/sources.list
	fi
	# Backup all previous /etc/apt/sources.list.d/kt-*.list
	if ls /etc/apt/sources.list.d/kt-*.list > /dev/null 2>&1 ; then
		mkdir -p "$LIBDIR/sources.list.bkpd"
		mv -b /etc/apt/sources.list.d/kt-*.list "$LIBDIR/sources.list.bkpd/"
	fi

	# Check and warn if other sources.list exist.
	if grep -s "^[[:space:]]*[^#]" /etc/apt/sources.list.d/*.{list,sources} >&2 ; then
		echo "$FUNCNAME: Warning: extra sources.list may conflict with kt-remote.list" >&2
	fi

	# put our New sources list
	cp -v "$LIBDIR/remote_sources.list" /etc/apt/sources.list.d/kt-remote.list || return $?

	kt_cleancache

	# store successful getconf_id
	echo "$KT_SERVER_URI" > "$LIBDIR/getconf_server" || return $?
	echo "$id" > "$LIBDIR/getconf_id" || return $?
	date "+%s" > "$LIBDIR/getconf_date" || return $?
}

kt_listids() {
	if (( ${#KT_SERVER_URI} < 11 )) ; then
		echo "$FUNCNAME: No server correctly configured" >&2
		return 197
	fi

	 wget $WGET_OPTIONS -q -O - "$KT_SERVER_URI/cids/index" | grep -o "^[^#]*" && return

	 local ret=${PIPESTATUS[0]}

	 #TODO: put such case... esac in a function to be used for all wget calls (cf. "^#~kt:update:extrafile:")
	 case $ret in
		0) echo "$FUNCNAME: Server issued an empty response." >&2 ;;
		2) echo "$FUNCNAME: Parse error---for instance, when parsing command-line options, the .wgetrc or .netrc..." >&2 ;;
		3) echo "$FUNCNAME: File I/O error." >&2 ;;
		4) echo "$FUNCNAME: Network failure." >&2 ;;
		5) echo "$FUNCNAME: SSL verification failure." >&2 ;;
		6) echo "$FUNCNAME: Username/password authentication failure." >&2 ;;
		7) echo "$FUNCNAME: Protocol errors." >&2 ;;
		8) echo "$FUNCNAME: Server issued an error response (it may be intentional)." >&2 ;;
		*) echo "$FUNCNAME: Unknow wget error ($ret)." >&2 ;;
	esac

	return $ret
}

# If no media given then:
#  * if IDENTIFIER or KT_SERVER_URI have changed, run first a kt_getconf()
#  * manage sources.list kt extensions
# Try "apt-get update". If that fails then kt_getconf() and retry once.
kt_update() {
	local ret MEDIA rmktlist=false
	local helpmsg=" update       check for packages updates. Options:
    -n, --no-ktsource    remove apt source list given from kt-server.
    -m, --media  PATH    update from a PATH (mounted ISO) in addition to other source lists."

	for ((;$#;)) ; do
		case "$1" in
			-n|--no-ktsource) rmktlist=true ;;
			-m|--media) shift ; MEDIA="$1" ;;
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			*) echo -e "$FUNCNAME: Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done

	if [ "$MEDIA" ] ; then
		apt-cdrom -m -n --cdrom "$MEDIA" add | sed -n " s,^deb cdrom:\[[^]]\+\]/ \(.*\)$,deb copy://${MEDIA// /%20} \1,p " | tee /etc/apt/sources.list.d/kt-media.list
		ret=$((PIPESTATUS[0]|PIPESTATUS[2]))
		((ret)) && return $ret
		kt_cleancache
		# Force cleaning cache on futur update without --media option.
		rm $LIBDIR/cache-cleaned
	else
		#Clean eventual additionnal media source list.
		rm -vf /etc/apt/sources.list.d/kt-media.list
		[ -f "$LIBDIR/cache-cleaned" ] || kt_cleancache
	fi

	local authid authserver lastauth reauth=false
	if $rmktlist ; then
		rm -vf /etc/apt/sources.list.d/kt-remote.list
		apt-get $APT_OPTIONS update || return $?
	elif ! [ -f /etc/apt/sources.list.d/kt-remote.list ] ; then
		echo "$FUNCNAME: Info: No kt-remote.list => get configuration..." >&2
		reauth=true
	elif ! read authid < "$LIBDIR/getconf_id" || [[ "$authid" != "$IDENTIFIER" ]] ; then
		echo "$FUNCNAME: Info: new config id '$IDENTIFIER' imply to get new configuration..." >&2
		reauth=true
	elif ! read authserver < "$LIBDIR/getconf_server" || [[ "$authserver" != "$KT_SERVER_URI" ]] ; then
		echo "$FUNCNAME: Info: new kt server '$KT_SERVER_URI' imply to get new configuration..." >&2
		reauth=true
	#elif ! read lastauth < "$LIBDIR/getconf_date" || (( KT_GETCONF_PERIOD >= 0 && lastauth + KT_GETCONF_PERIOD*86400 < $(date "+%s") )) ; then # BASH BUG (version 4.4.12) !!!!
	elif (( KT_GETCONF_PERIOD >=0 )) && { ! read lastauth < "$LIBDIR/getconf_date" || (( lastauth + KT_GETCONF_PERIOD*86400 < $(date "+%s") )) ; } ; then
		echo "$FUNCNAME: Info: No getconf since $(( ($(date "+%s") - lastauth)/86400 )) days => getconf."
		reauth=true
	elif ! apt-get $APT_OPTIONS update ; then
		# If apt-get update fail once, force re-auth (remote sources.list may have changed)
		echo "$FUNCNAME: Warning: Remote source list may have changed..." >&2
		reauth=true
	fi

	if $reauth ; then
		kt_getconf "$IDENTIFIER" && apt-get $APT_OPTIONS update || return $?
	fi

	local dc flags signedfrom target
	mkdir -p "$LIBDIR/update"
	grep "^#~kt:update:extrafile:" /etc/apt/sources.list.d/kt-remote.list | while IFS=":" read dc dc dc flags signedfrom target ; do
		# remove characters that could create a security hole.
		target="${target//[|;& ]/}"

		rm -rf "$TMPDIR/update"
		wget $WGET_OPTIONS -P "$TMPDIR/update/" "$target"
		#TODO: eventually use "-N" wget option (timestamp-checking) to avoid downloading big unchanged files.
		ret=$?
		if ((ret)) ; then
			if [[ "$flags" =~ c ]] ; then # critical file
				echo "$FUNCNAME: Error: wget $target fail ($ret)" >&2
				kt_getconf "$IDENTIFIER"
				#TODO: improve behaviour. Workaround yet : relaunch (function)action (kt_)update.
				return $ret
			else
				continue
			fi
		fi

		if [[ "$flags" =~ s ]] ; then
			#TODO: implement possibility to download signed (and eventualy encrypted) files.
			echo "$FUNCNAME:Warning: signed extrafile not implemented" >&2
			mv "$TMPDIR/update/"* "$LIBDIR/update"
		else
			mv "$TMPDIR/update/"* "$LIBDIR/update"
		fi
	done

	apt-get $APT_OPTIONS update || return $?

	apt-get $APT_OPTIONS -o APT::Get::Simulate=true dist-upgrade || return $?
}

kt_upgrade() {
	local i=1
	local helpmsg=" upgrade      download and install new packages"
	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			*) echo -e "Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done

	apt-get $APT_OPTIONS autoclean

	dpkg --configure -a
	apt-get $APT_OPTIONS dist-upgrade
	while ((PIPESTATUS[0]|PIPESTATUS[1])) ; do
		echo -e "\n\n  --- $i ...\n\n" ;
		apt-get $APT_OPTIONS -f install ;
		echo -e "\n\n  ... $((i++)) ---\n\n" ;
		read -t 5 ;
		if ((i>5)) ; then
			echo "ERROR: Update failed, please contact your configuration manager(s)." >&2
			return 10
		fi
		apt-get $APT_OPTIONS dist-upgrade
	done

	return 0
}

kt_install() {
	local cpkgs
	if cpkgs="$(kt_requiredpkgs)" ; then
		if apt-get $APT_OPTIONS --no-act install "$@" | grep "^\(Remv\|Purg\) \(${cpkgs//$'\n'/\\|}\) " ; then
			echo "$FUNCNAME: Error: Some package you want to install will broke your configuration." >&2
			return 1
		fi
	else
		if apt-get $APT_OPTIONS --no-act install "$@" | grep "^\(Remv\|Purg\) " ; then
			echo "$FUNCNAME: Error: Your configuration shows no required package, this may broke your distribution." >&2
			return 1
		fi
	fi
	apt-get $APT_OPTIONS install "$@"
}

kt_purge() {
	local cpkgs
	if cpkgs="$(kt_requiredpkgs)" ; then
		if apt-get $APT_OPTIONS --no-act purge "$@" | grep "^\(Remv\|Purg\) \(${cpkgs//$'\n'/\\|}\) " ; then
			echo "$FUNCNAME: Error: Some package you want to purge will broke your configuration." >&2
			return 1
		fi
	else
		echo "$FUNCNAME: Error: Your configuration shows no required package, you may broke your distribution." >&2
		return 1

	fi
	apt-get $APT_OPTIONS purge "$@"
}

kt_clean() {
	local helpmsg=" clean        auto remove obsolete packages and purge downloaded *.deb files. Options:
	-B, --big	unmark and remove also all packages not required by the \"kt:check:package:\" in kt-remote.list"
	local cpkgs big=0 i mpkgs

	for ((;$#;)) ; do
		case "$1" in
			-h|--h*) echo "$helpmsg" ; return ;;
			-V|--vers*) echo "$FUNCNAME $KT_VERSION" ; return ;;
			-B|--big) big=1 ;;
			*) echo -e "Error: Unrecognized option/parameter $1\n$helpmsg" >&2 ; return 2 ;;
		esac
		shift
	done

	if ((big)) ; then
		if cpkgs="$(kt_requiredpkgs)" ; then
			if ! diff -  <(dpkg --get-selections $cpkgs | sed -n 's,^\([^:[[:space:]]\+\).*[[:space:]]install$,\1,p') <<< "$cpkgs" ; then
				echo "$FUNCNAME: Warning: Some expected packages are not currently installed. It may be a wise idea to run a checknfix and press CTRL-C NOW !" >&2
				for ((i=15;i>0;i--)) ; do echo -n " $i " >&2 ; sleep 1 ; done
				echo >&2
			fi
			mpkgs="$(apt-mark showmanual | grep -v "^\(${cpkgs//$'\n'/\\|}\)$" )"
			if [ "$mpkgs" ] ; then
				apt-mark auto $mpkgs || return $?
			fi
		else
			echo "$FUNCNAME: Warning: Your configuration shows no required package, ignoring --big option. " >&2
		fi
	fi
	apt-get $APT_OPTIONS autoremove || return $?
	apt-get $APT_OPTIONS clean || return $?
	if [ "$mpkgs" ] && [[ "$APT_OPTIONS" =~ APT::Get::Simulate=true ]] ; then
		apt-mark manual $mpkgs || return $?
	fi
}

